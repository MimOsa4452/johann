---
phase: 01-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/GameState.js
  - src/scenes/GameScene.js
  - src/scenes/HUDScene.js
autonomous: true

must_haves:
  truths:
    - "Two cameras exist in GameScene — main camera (world) and uiCamera (HUD/overlay)"
    - "African bush placeholder background fills the game viewport and is rendered by the main camera"
    - "Rifle/scope overlay skeleton is visible in the unzoomed view (dark frame rectangle at bottom)"
    - "GameState object exists on GameScene with get(), setState(), and reset() methods"
    - "HUDScene receives a stateChange event from GameScene when setState() is called"
    - "A Phaser timer (not setInterval) is scaffolded in GameScene using this.time.addEvent()"
    - "Scope dark overlay Graphics object and scope circle Graphics object exist on GameScene with correct depths"
  artifacts:
    - path: "src/GameState.js"
      provides: "createGameState(scene) factory — INITIAL_STATE, get(), setState(), reset()"
      exports: ["createGameState", "INITIAL_STATE"]
    - path: "src/scenes/GameScene.js"
      provides: "Two-camera setup, background placeholder, scope overlay bones, GameState wiring, Phaser timer"
      contains: "this.uiCamera"
    - path: "src/scenes/HUDScene.js"
      provides: "stateChange event listener from GameScene, score/timer display updated from events"
      contains: "stateChange"
  key_links:
    - from: "src/scenes/GameScene.js"
      to: "src/GameState.js"
      via: "import createGameState; this.gameState = createGameState(this)"
      pattern: "createGameState"
    - from: "src/scenes/GameScene.js"
      to: "this.uiCamera"
      via: "this.cameras.add(0, 0, width, height, false, 'ui')"
      pattern: "cameras.add"
    - from: "src/scenes/GameScene.js"
      to: "src/scenes/HUDScene.js"
      via: "this.events.emit('stateChange', state) in GameState.setState()"
      pattern: "stateChange"
    - from: "src/scenes/HUDScene.js"
      to: "GameScene events"
      via: "gameScene.events.on('stateChange', handler)"
      pattern: "events.on.*stateChange"
---

<objective>
Establish the core architectural systems in GameScene: two-camera setup, GameState object, placeholder background rendering, scope overlay skeleton, and a Phaser-based timer stub. These are the irreversible Phase 1 decisions — correct architecture here prevents cascading rewrites in Phase 2.

Purpose: Phase 2 will add animals, real aiming, and round flow directly on top of these systems. If the camera separation or GameState pattern is wrong here, Phase 2 requires a full GameScene rewrite.
Output: GameScene with provably correct two-camera setup, a GameState factory used for all state mutations, placeholder bush background visible to the main camera, scope overlay Graphics objects at correct depths, and a Phaser timer stub. HUDScene subscribes to GameScene state events.
</objective>

<execution_context>
@/home/hrmnn/.claude/get-shit-done/workflows/execute-plan.md
@/home/hrmnn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameState factory and two-camera setup in GameScene</name>
  <files>src/GameState.js, src/scenes/GameScene.js</files>
  <action>
    **Create `src/GameState.js`:**

    ```javascript
    // All mutable round state lives here. No this.score, this.timeLeft on the scene class.
    // Use setState(patch) for all mutations — it emits 'stateChange' for HUDScene to consume.

    export const INITIAL_STATE = {
      score:     0,
      timeLeft:  90,
      phase:     'idle',   // 'idle' | 'playing' | 'paused' | 'ended'
      roundCount: 0,
    };

    export function createGameState(scene) {
      let state = { ...INITIAL_STATE };

      return {
        get()          { return { ...state }; },
        setState(patch) {
          state = { ...state, ...patch };
          scene.events.emit('stateChange', { ...state });
        },
        reset() {
          state = { ...INITIAL_STATE };
          scene.events.emit('stateChange', { ...state });
        },
      };
    }
    ```

    **Rewrite `src/scenes/GameScene.js` create() with full Phase 1 architecture:**

    ```javascript
    import { SCENE_KEYS, DEPTH } from '../constants.js';
    import { createGameState }   from '../GameState.js';

    export class GameScene extends Phaser.Scene {
      constructor() { super({ key: SCENE_KEYS.GAME }); }

      create() {
        const { width, height } = this.scale;

        // ── 1. GameState ─────────────────────────────────────────────────────
        this.gameState = createGameState(this);

        // ── 2. Two-camera setup ───────────────────────────────────────────────
        // Main camera: renders world (background, animals, scope overlay)
        this.cameras.main.setBackgroundColor('#3d5a2a'); // dark savanna green placeholder

        // UI camera: renders HUD, crosshair, scope frame — never scrolls/zooms
        this.uiCamera = this.cameras.add(0, 0, width, height, false, 'ui');
        this.uiCamera.setBackgroundColor('rgba(0,0,0,0)');

        // ── 3. Background placeholder ─────────────────────────────────────────
        // Solid color rects to prove main camera depth layers.
        // Phase 2 replaces these with real atlas sprites.
        // All world objects are ignored by uiCamera (ignore list added as objects are created).

        const sky = this.add.rectangle(width / 2, height * 0.3, width, height * 0.6, 0x87ceeb)
          .setDepth(DEPTH.SKY);                         // sky blue
        const hills = this.add.rectangle(width / 2, height * 0.55, width, height * 0.3, 0x6b8e4e)
          .setDepth(DEPTH.HILLS);                       // mid-green hills
        const ground = this.add.rectangle(width / 2, height * 0.8, width, height * 0.4, 0xc8a060)
          .setDepth(DEPTH.MIDGROUND);                   // savanna tan ground

        this.uiCamera.ignore([sky, hills, ground]);

        // ── 4. Scope overlay skeleton ─────────────────────────────────────────
        // Phase 1: scope bones only. Phase 2 adds Shift-key toggle and circular mask.
        // scopeOverlay = full-screen dark vignette (hidden by default)
        this.scopeOverlay = this.add.graphics()
          .setDepth(DEPTH.SCOPE_DARK)
          .setScrollFactor(0)
          .setVisible(false);                           // shown in Phase 2 on Shift hold
        this.scopeOverlay.fillStyle(0x000000, 0.85);
        this.scopeOverlay.fillRect(0, 0, width, height);

        // scopeCircle = circular mask shape for the lens cutout
        this.scopeCircle = this.add.graphics()
          .setDepth(DEPTH.SCOPE_WINDOW)
          .setScrollFactor(0)
          .setVisible(false);
        const scopeRadius = 120;
        this.scopeCircle.fillStyle(0xffffff);
        this.scopeCircle.fillCircle(width / 2, height / 2, scopeRadius);

        // Rifle overlay: dark rectangle at bottom simulating stock/barrel silhouette
        const rifleBar = this.add.rectangle(width / 2, height - 30, width, 60, 0x1a0a00)
          .setDepth(DEPTH.SCOPE_WINDOW)
          .setScrollFactor(0);                         // stays fixed — not a world object

        // All scope/UI objects ignored by main camera? No — they're in world space but
        // scrollFactor 0 keeps them fixed. uiCamera ignores them too (they belong on main).
        this.uiCamera.ignore([this.scopeOverlay, this.scopeCircle, rifleBar]);

        // ── 5. Phaser timer scaffold ──────────────────────────────────────────
        // Not started until phase = 'playing' in Phase 2. Declared here for architecture.
        // Do NOT use setInterval — Phaser.Time.TimerEvent pauses with the game loop.
        this.roundTimer = null;   // assigned via this.startRoundTimer() in Phase 2

        // ── 6. Launch HUDScene in parallel ────────────────────────────────────
        this.scene.launch(SCENE_KEYS.HUD);

        // ── 7. Dev shortcut — remove in Phase 2 ──────────────────────────────
        const rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        rKey.once('down', () => {
          this.scene.stop(SCENE_KEYS.HUD);
          this.scene.start(SCENE_KEYS.RESULT, { score: this.gameState.get().score, roundNum: 1 });
        });

        // ── 8. Shutdown cleanup ───────────────────────────────────────────────
        this.events.once('shutdown', () => {
          rKey.destroy();
          if (this.roundTimer) { this.roundTimer.remove(); }
          // HUDScene listeners cleaned up in HUDScene shutdown handler
        });
      }

      // Scaffold for Phase 2 — start the Phaser countdown timer
      startRoundTimer() {
        this.roundTimer = this.time.addEvent({
          delay:         1000,
          callback:      this.onTimerTick,
          callbackScope: this,
          repeat:        89,   // 90 total ticks: initial fire + 89 repeats
        });
        this.gameState.setState({ phase: 'playing' });
      }

      onTimerTick() {
        const newTime = this.gameState.get().timeLeft - 1;
        this.gameState.setState({ timeLeft: newTime });
        if (newTime <= 0) {
          this.onRoundEnd();
        }
      }

      onRoundEnd() {
        if (this.roundTimer) { this.roundTimer.remove(); }
        this.gameState.setState({ phase: 'ended' });
        this.scene.stop(SCENE_KEYS.HUD);
        this.scene.start(SCENE_KEYS.RESULT, {
          score:    this.gameState.get().score,
          roundNum: this.gameState.get().roundCount,
        });
      }
    }
    ```

    Key implementation notes:
    - `this.uiCamera.ignore([...])` must be called for every world object added. Forgetting this causes HUD blur or depth issues when main camera zooms in Phase 2.
    - `setScrollFactor(0)` on scope overlay keeps it fixed to viewport even if main camera scrolls in Phase 2.
    - `scopeOverlay.setVisible(false)` — Phase 1 does not activate the scope. Bones must be present and at correct depth.
    - `Phaser.AUTO` is set in main.js — never override to Phaser.WEBGL, would break Safari Canvas fallback.
  </action>
  <verify>
    Open localhost:3000 → navigate to GameScene (press Space on menu).
    Verify in browser console:
    1. `window.__game = Phaser.Display.Canvas.CanvasInterpolation` — not needed; instead check DevTools:
       Open the Phaser debug panel or run in console: `window.game?.scene.getScene('GameScene')?.cameras?.cameras?.length` → should be 2
    2. Inspect the scene visually: dark savanna background visible (green + tan + blue sky), dark rifle bar at bottom
    3. No console errors on load or navigation
    4. In browser console: `window.game?.scene.getScene('GameScene')?.gameState?.get()` → returns `{ score: 0, timeLeft: 90, phase: 'idle', roundCount: 0 }`
  </verify>
  <done>
    GameScene has exactly 2 cameras. gameState.get() returns INITIAL_STATE values. Background placeholder layers are visible. scopeOverlay and scopeCircle Graphics objects exist at DEPTH.SCOPE_DARK and DEPTH.SCOPE_WINDOW. rifleBar is visible at bottom of screen.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HUDScene to GameScene stateChange events</name>
  <files>src/scenes/HUDScene.js</files>
  <action>
    **Rewrite `src/scenes/HUDScene.js`** to subscribe to `stateChange` events from GameScene. HUDScene renders score and timer text that updates whenever GameState changes.

    ```javascript
    import { SCENE_KEYS, DEPTH } from '../constants.js';

    export class HUDScene extends Phaser.Scene {
      constructor() { super({ key: SCENE_KEYS.HUD }); }

      create() {
        const { width, height } = this.scale;

        // HUDScene renders above GameScene — registered after it in scene array.
        // All text here is UI layer — not subject to main camera transforms.

        // Score display — top left
        this.scoreText = this.add.text(20, 20, 'Score: 0', {
          fontSize: '28px',
          color: '#ffffff',
          stroke: '#000000',
          strokeThickness: 4,
        }).setDepth(DEPTH.HUD);

        // Timer display — top right
        this.timerText = this.add.text(width - 20, 20, 'Time: 90', {
          fontSize: '28px',
          color: '#ffffff',
          stroke: '#000000',
          strokeThickness: 4,
        }).setOrigin(1, 0).setDepth(DEPTH.HUD);

        // Subscribe to GameScene state changes
        // GameScene emits 'stateChange' on every setState() call
        const gameScene = this.scene.get(SCENE_KEYS.GAME);
        const onStateChange = (state) => {
          this.scoreText.setText(`Score: ${state.score}`);
          this.timerText.setText(`Time: ${state.timeLeft}`);
        };
        gameScene.events.on('stateChange', onStateChange, this);

        // Cleanup: remove listener when HUDScene shuts down
        // (scene.stop() is called from GameScene before transitioning to ResultScene)
        this.events.once('shutdown', () => {
          gameScene.events.off('stateChange', onStateChange, this);
        });
      }
    }
    ```

    Implementation notes:
    - HUDScene must NOT call `this.scene.get(SCENE_KEYS.GAME)` before GameScene is running. Since GameScene launches HUDScene via `this.scene.launch()`, GameScene is always running when HUDScene.create() fires.
    - `gameScene.events.off('stateChange', onStateChange, this)` — pass the same reference and context used in `on()` to avoid ghost listeners.
    - HUDScene text objects live in HUDScene's own camera (the default camera for HUDScene). They do not interact with GameScene's uiCamera. This is correct — HUDScene is an entirely separate scene with its own default camera.
    - Do NOT add a second camera inside HUDScene — it already renders as a separate scene on top of GameScene.
  </action>
  <verify>
    Navigate to GameScene in browser.
    1. "Score: 0" and "Time: 90" text visible at top of screen over the background
    2. In browser console, trigger a state change to confirm event wiring:
       ```javascript
       window.game.scene.getScene('GameScene').gameState.setState({ score: 42, timeLeft: 77 })
       ```
       HUD text should immediately update to "Score: 42" and "Time: 77" without page reload.
    3. Press R to go to ResultScene — no errors in console (HUDScene shutdown cleanup fired)
    4. Navigate back to GameScene — HUD shows "Score: 0" and "Time: 90" again (fresh create())
  </verify>
  <done>
    HUDScene displays score and timer text. `setState({ score: X })` on GameScene immediately updates HUDScene text. No ghost listeners after scene transition (verified by navigating Game → Result → Menu → Game again without duplicate HUD updates).
  </done>
</task>

</tasks>

<verification>
Full architecture check:
1. In GameScene, `this.cameras.cameras.length === 2` (console confirm)
2. `this.gameState.get()` returns `{ score: 0, timeLeft: 90, phase: 'idle', roundCount: 0 }`
3. `this.gameState.setState({ score: 10 })` → HUDScene score text updates to "Score: 10"
4. Background layers visible: sky (blue), hills (green), ground (tan), rifle bar (dark) at bottom
5. `this.scopeOverlay` exists and is at depth 50, `this.scopeCircle` at depth 60 (Phase 2 will toggle visibility)
6. Press R → ResultScene transition → Space → MenuScene → Space → GameScene loads fresh with score 0
7. Zero console errors throughout
</verification>

<success_criteria>
- Two cameras exist in GameScene: `cameras.main` (world) and `this.uiCamera` (UI)
- Background placeholder (sky + hills + ground rectangles) visible in viewport at correct DEPTH layers
- Rifle bar silhouette visible at bottom of screen at DEPTH.SCOPE_WINDOW
- `scopeOverlay` and `scopeCircle` Graphics objects exist at DEPTH.SCOPE_DARK and DEPTH.SCOPE_WINDOW (invisible — activated in Phase 2)
- `createGameState(scene)` factory returns object with `get()`, `setState()`, `reset()` — all mutations emit 'stateChange'
- HUDScene `scoreText` and `timerText` update live from GameScene stateChange events
- Phaser timer scaffold (`startRoundTimer()`, `onTimerTick()`) exists in GameScene but is not yet started
- `npm run build` produces clean production bundle
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` using the summary template.
</output>
